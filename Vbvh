# meta developer: @kiminaiq
# meta pic: https://img.icons8.com/color/48/000000/money-bag.png
# meta description: –ü—É–±–ª–∏–∫–∞—Ü–∏—è –∫—É—Ä—Å–æ–≤ USD –∏ TON –≤ ‚ÇΩ –≤ –∫–∞–Ω–∞–ª @priceDollarTon
# scope: hikka_only
# scope: hikka_min 1.6.0

import aiohttp
import asyncio
import time
from datetime import datetime
from .. import loader, utils
import logging

logger = logging.getLogger(__name__)

@loader.tds
class PricePosterSimple(loader.Module):
    """–ü—É–±–ª–∏–∫–∞—Ü–∏—è –∫—É—Ä—Å–æ–≤ USD –∏ TON –≤ ‚ÇΩ –≤ @priceDollarTon"""
    
    strings = {
        "name": "PricePosterSimple",
        "started": "‚úÖ <b>–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!</b>\nüì¢ –ö–∞–Ω–∞–ª: @priceDollarTon\n‚è± –ö–∞–∂–¥—ã–µ 3 –º–∏–Ω—É—Ç—ã\nüíµ USD –≤ RUB\nüíé TON –≤ RUB",
        "stopped": "‚èπÔ∏è <b>–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>",
        "already_running": "‚ö†Ô∏è <b>–ë–æ—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç</b>",
        "not_running": "üì≠ <b>–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω</b>",
        "test_sent": "üì§ <b>–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω</b>",
        "status": "üîÑ <b>–°—Ç–∞—Ç—É—Å:</b> {}\n‚è∞ <b>–ü–æ—Å–ª–µ–¥–Ω–µ–µ:</b> {}",
        "error": "‚ùå <b>–û—à–∏–±–∫–∞:</b> {}",
        "updating": "üîÑ –ü–æ–ª—É—á–∞—é –∫—É—Ä—Å—ã..."
    }
    
    def __init__(self):
        self.task = None
        self.is_running = False
        self.last_update = None
        self.session = None
        self.last_usd_price = None
        self.last_ton_price = None
    
    async def client_ready(self, client, db):
        self.client = client
        self.db = db
        self.session = aiohttp.ClientSession()
        logger.info("PricePosterSimple –∑–∞–≥—Ä—É–∂–µ–Ω")
    
    @loader.command(
        ru_doc="–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø—É–±–ª–∏–∫–∞—Ü–∏—é —Ü–µ–Ω –≤ @priceDollarTon",
        en_doc="Start posting prices to @priceDollarTon"
    )
    async def startpricepostcmd(self, message):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"""
        if self.is_running:
            await utils.answer(message, self.strings("already_running"))
            return
        
        self.is_running = True
        self.task = asyncio.create_task(self._posting_loop())
        
        await utils.answer(message, self.strings("started"))
        logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    
    @loader.command(
        ru_doc="–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞",
        en_doc="Stop bot"
    )
    async def stoppricepostcmd(self, message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞"""
        if not self.is_running:
            await utils.answer(message, self.strings("not_running"))
            return
        
        self.is_running = False
        if self.task:
            self.task.cancel()
            self.task = None
        
        await utils.answer(message, self.strings("stopped"))
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    @loader.command(
        ru_doc="–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç",
        en_doc="Test post"
    )
    async def testpostcmd(self, message):
        """–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç"""
        await utils.answer(message, self.strings("updating"))
        try:
            usd_rub, ton_rub = await self._get_prices()
            
            if usd_rub and ton_rub:
                post = self._format_post(usd_rub, ton_rub)
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª
                await self.client.send_message(
                    "@priceDollarTon",
                    post,
                    parse_mode='HTML'
                )
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–µ–±–µ
                await utils.answer(message, self.strings("test_sent"))
                await message.respond(post, parse_mode='HTML')
            else:
                await utils.answer(message, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å—ã")
                
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    @loader.command(
        ru_doc="–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞",
        en_doc="Bot status"
    )
    async def pricestatuscmd(self, message):
        """–°—Ç–∞—Ç—É—Å"""
        status = "üü¢ –†–∞–±–æ—Ç–∞–µ—Ç" if self.is_running else "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        
        last_time = "‚Äî"
        if self.last_update:
            last_time = datetime.fromtimestamp(self.last_update).strftime("%H:%M:%S")
        
        info = f"{status}\n‚è∞ –ü–æ—Å–ª–µ–¥–Ω–µ–µ: {last_time}"
        
        if self.last_usd_price and self.last_ton_price:
            info += f"\n\nüíµ –¢–µ–∫—É—â–∏–π USD: {self.last_usd_price:.2f}‚ÇΩ\n"
            info += f"üíé –¢–µ–∫—É—â–∏–π TON: {self.last_ton_price:.2f}‚ÇΩ"
        
        await utils.answer(message, info)
    
    @loader.command(
        ru_doc="–û–±–Ω–æ–≤–∏—Ç—å —Å–µ–π—á–∞—Å",
        en_doc="Update now"
    )
    async def updatepricescmd(self, message):
        """–û–±–Ω–æ–≤–∏—Ç—å"""
        await utils.answer(message, self.strings("updating"))
        try:
            usd_rub, ton_rub = await self._get_prices()
            
            if usd_rub and ton_rub:
                post = self._format_post(usd_rub, ton_rub)
                await message.respond(post, parse_mode='HTML')
            else:
                await utils.answer(message, "‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö")
                
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    async def _posting_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø—É–±–ª–∏–∫–∞—Ü–∏–∏"""
        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã
                usd_rub, ton_rub = await self._get_prices()
                
                if usd_rub and ton_rub:
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞
                    self.last_usd_price = usd_rub
                    self.last_ton_price = ton_rub
                    
                    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –ø–æ—Å—Ç
                    post = self._format_post(usd_rub, ton_rub)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª
                    await self.client.send_message(
                        "@priceDollarTon",
                        post,
                        parse_mode='HTML'
                    )
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
                    self.last_update = time.time()
                    
                    logger.info(f"–ü–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω | USD: {usd_rub:.2f}‚ÇΩ, TON: {ton_rub:.2f}‚ÇΩ")
                
                # –ñ–¥–µ–º 3 –º–∏–Ω—É—Ç—ã (180 —Å–µ–∫—É–Ω–¥)
                for _ in range(180):
                    if not self.is_running:
                        break
                    await asyncio.sleep(1)
                    
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: {e}")
                await asyncio.sleep(30)  # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
    
    async def _get_prices(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ USD/RUB –∏ TON/RUB"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º USD/RUB
            usd_rub = await self._get_usd_rub()
            
            # –ü–æ–ª—É—á–∞–µ–º TON/USD
            ton_usd = await self._get_ton_usd()
            
            if usd_rub and ton_usd:
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º TON –≤ RUB
                ton_rub = ton_usd * usd_rub
                return usd_rub, ton_rub
            
            return None, None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω: {e}")
            return None, None
    
    async def _get_usd_rub(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ USD/RUB"""
        try:
            # –ü–µ—Ä–≤—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫
            url = "https://api.frankfurter.app/latest?from=USD&to=RUB"
            async with self.session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['rates']['RUB']
        except:
            pass
        
        # –í—Ç–æ—Ä–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫
        try:
            url = "https://api.exchangerate-api.com/v4/latest/USD"
            async with self.session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['rates']['RUB']
        except:
            pass
        
        return None
    
    async def _get_ton_usd(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ TON/USD"""
        try:
            # Binance API
            url = "https://api.binance.com/api/v3/ticker/price?symbol=TONUSDT"
            async with self.session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    return float(data['price'])
        except:
            pass
        
        # CoinGecko API
        try:
            url = "https://api.coingecko.com/api/v3/simple/price"
            params = {"ids": "the-open-network", "vs_currencies": "usd"}
            async with self.session.get(url, params=params, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['the-open-network']['usd']
        except:
            pass
        
        return None
    
    def _format_post(self, usd_rub, ton_rub):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞ –≤ –Ω—É–∂–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ"""
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —á–∏—Å–ª–∞
        usd_formatted = f"{usd_rub:,.2f}".replace(",", " ").replace(".", ",")
        ton_formatted = f"{ton_rub:,.2f}".replace(",", " ").replace(".", ",")
        
        # –£–±–∏—Ä–∞–µ–º –∫–æ–ø–µ–π–∫–∏ –µ—Å–ª–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
        if ton_rub.is_integer():
            ton_formatted = f"{int(ton_rub):,}".replace(",", " ")
        
        # –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
        time_now = datetime.now().strftime("%H:%M")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ—Å—Ç
        post = f"üíµ USD: <b>{usd_formatted}‚ÇΩ</b>\n"
        post += f"üíé TON: <b>{ton_formatted}‚ÇΩ</b>\n\n"
        post += f"<i>üïê {time_now} | @priceDollarTon</i>"
        
        return post
    
    async def on_unload(self):
        """–û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ"""
        self.is_running = False
        
        if self.task:
            self.task.cancel()
        
        if self.session:
            await self.session.close()

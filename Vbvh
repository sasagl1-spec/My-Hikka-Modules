# meta developer: @kiminaiq  
# meta pic: https://img.icons8.com/color/48/000000/dollar--v1.png
# meta description: –ê–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥ —Ü–µ–Ω USD/TON –≤ –∫–∞–Ω–∞–ª @priceDollarTon
# scope: hikka_only
# scope: hikka_min 1.6.0

import aiohttp
import asyncio
import json
import time
from datetime import datetime
from decimal import Decimal, ROUND_HALF_UP
from .. import loader, utils
import logging

logger = logging.getLogger(__name__)

@loader.tds
class DollarTonPriceBot(loader.Module):
    """–ê–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥ —Ü–µ–Ω USD/RUB –∏ TON –≤ @priceDollarTon"""
    
    strings = {
        "name": "DollarTonPrice",
        "started": "‚úÖ <b>–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!</b>\nüì¢ –ö–∞–Ω–∞–ª: @priceDollarTon\n‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª: 3 –º–∏–Ω—É—Ç—ã\nüìä –ü–∞—Ä—ã: USD/RUB, TON/USD",
        "stopped": "‚èπÔ∏è <b>–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>",
        "already_running": "‚ö†Ô∏è <b>–ë–æ—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç</b>",
        "not_running": "üì≠ <b>–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω</b>",
        "test_sent": "üì§ <b>–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω</b>",
        "status": "üîÑ <b>–°—Ç–∞—Ç—É—Å:</b> {}\n‚è∞ <b>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:</b> {}\nüìà <b>–°–ª–µ–¥—É—é—â–µ–µ:</b> —á–µ—Ä–µ–∑ {} —Å–µ–∫",
        "error": "‚ùå <b>–û—à–∏–±–∫–∞:</b> {}",
        "updating": "üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö..."
    }
    
    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "target_channel",
                "@priceDollarTon",
                "–ö–∞–Ω–∞–ª –¥–ª—è –ø–æ—Å—Ç–∏–Ω–≥–∞",
                validator=loader.validators.String()
            ),
            loader.ConfigValue(
                "posting_interval",
                180,  # 3 –º–∏–Ω—É—Ç—ã –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
                "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ—Å—Ç–∏–Ω–≥–∞ (—Å–µ–∫—É–Ω–¥—ã)",
                validator=loader.validators.Integer(minimum=60, maximum=3600)
            ),
            loader.ConfigValue(
                "show_ton_price",
                True,
                "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ü–µ–Ω—É TON",
                validator=loader.validators.Boolean()
            ),
            loader.ConfigValue(
                "show_crypto_pairs",
                True,
                "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫—Ä–∏–ø—Ç–æ-–ø–∞—Ä—ã",
                validator=loader.validators.Boolean()
            ),
            loader.ConfigValue(
                "number_format",
                "üá∑üá∫",
                "–§–æ—Ä–º–∞—Ç —á–∏—Å–µ–ª (üá∑üá∫ –∏–ª–∏ üá∫üá∏)",
                validator=loader.validators.Choice(["üá∑üá∫", "üá∫üá∏"])
            )
        )
        self.task = None
        self.is_running = False
        self.last_update = None
        self.next_update = None
        self.session = None
        self.usd_rub = None
        self.ton_usd = None
        self.btc_usd = None
        self.eth_usd = None
    
    async def client_ready(self, client, db):
        self.client = client
        self.db = db
        self._client = client
        self.session = aiohttp.ClientSession()
        logger.info("DollarTonPriceBot –∑–∞–≥—Ä—É–∂–µ–Ω")
    
    @loader.command(
        ru_doc="–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –¥–ª—è –∫–∞–Ω–∞–ª–∞ @priceDollarTon",
        en_doc="Start bot for @priceDollarTon channel"
    )
    async def startpricebotcmd(self, message):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"""
        if self.is_running:
            await utils.answer(message, self.strings("already_running"))
            return
        
        self.is_running = True
        self.task = asyncio.create_task(self._price_posting_loop())
        
        await utils.answer(message, self.strings("started"))
        logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –¥–ª—è @priceDollarTon")
    
    @loader.command(
        ru_doc="–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞",
        en_doc="Stop bot"
    )
    async def stoppricebotcmd(self, message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞"""
        if not self.is_running:
            await utils.answer(message, self.strings("not_running"))
            return
        
        self.is_running = False
        if self.task:
            self.task.cancel()
            self.task = None
        
        await utils.answer(message, self.strings("stopped"))
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    @loader.command(
        ru_doc="–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –≤ –∫–∞–Ω–∞–ª",
        en_doc="Test post to channel"
    )
    async def testpricepostcmd(self, message):
        """–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç"""
        try:
            post_text = await self._generate_price_post()
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Ü–µ–ª–µ–≤–æ–π –∫–∞–Ω–∞–ª
            await self.client.send_message(
                self.config["target_channel"],
                post_text,
                parse_mode='HTML',
                link_preview=False
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–µ–±–µ –∫–æ–ø–∏—é
            await utils.answer(message, self.strings("test_sent"))
            await message.respond(post_text, parse_mode='HTML')
            
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    @loader.command(
        ru_doc="–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞",
        en_doc="Bot status"
    )
    async def pricebotstatuscmd(self, message):
        """–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞"""
        status_text = "üü¢ <b>–†–∞–±–æ—Ç–∞–µ—Ç</b>" if self.is_running else "üî¥ <b>–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>"
        
        last_update_str = "‚Äî"
        if self.last_update:
            last_update_str = datetime.fromtimestamp(self.last_update).strftime("%H:%M:%S")
        
        next_update_str = "‚Äî"
        if self.next_update:
            time_left = max(0, self.next_update - time.time())
            next_update_str = f"{int(time_left)} —Å–µ–∫"
        
        await utils.answer(
            message,
            self.strings("status").format(status_text, last_update_str, next_update_str)
        )
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã
        if self.usd_rub or self.ton_usd:
            current_prices = "<b>–¢–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ:</b>\n"
            if self.usd_rub:
                current_prices += f"üíµ USD/RUB: <code>{self.usd_rub:.2f}</code>\n"
            if self.ton_usd:
                current_prices += f"üíé TON/USD: <code>{self.ton_usd:.4f}</code>"
            await message.respond(current_prices, parse_mode='HTML')
    
    @loader.command(
        ru_doc="–û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å–µ–π—á–∞—Å",
        en_doc="Update data now"
    )
    async def updatenowcmd(self, message):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å–µ–π—á–∞—Å"""
        await utils.answer(message, self.strings("updating"))
        try:
            await self._fetch_all_prices()
            post_text = await self._generate_price_post()
            await message.respond("‚úÖ –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã\n\n" + post_text[:300], parse_mode='HTML')
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    async def _price_posting_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø–æ—Å—Ç–∏–Ω–≥–∞"""
        logger.info("–¶–∏–∫–ª –ø–æ—Å—Ç–∏–Ω–≥–∞ –Ω–∞—á–∞—Ç")
        
        while self.is_running:
            try:
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                self.next_update = time.time() + self.config["posting_interval"]
                
                # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
                await self._fetch_all_prices()
                
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ—Å—Ç
                post_text = await self._generate_price_post()
                
                await self.client.send_message(
                    self.config["target_channel"],
                    post_text,
                    parse_mode='HTML',
                    link_preview=False
                )
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ—Å—Ç–∞
                self.last_update = time.time()
                
                logger.info(f"–ü–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ @priceDollarTon | USD/RUB: {self.usd_rub}, TON/USD: {self.ton_usd}")
                
                # –ñ–¥–µ–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                wait_time = self.config["posting_interval"]
                while wait_time > 0 and self.is_running:
                    await asyncio.sleep(min(10, wait_time))
                    wait_time -= 10
                    
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –ø–æ—Å—Ç–∏–Ω–≥–∞: {e}")
                await asyncio.sleep(30)  # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
    
    async def _fetch_all_prices(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Ü–µ–Ω"""
        tasks = [
            self._fetch_usd_rub(),
            self._fetch_ton_price(),
            self._fetch_btc_price(),
            self._fetch_eth_price()
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        if not isinstance(results[0], Exception):
            self.usd_rub = results[0]
        if not isinstance(results[1], Exception):
            self.ton_usd = results[1]
        if not isinstance(results[2], Exception):
            self.btc_usd = results[2]
        if not isinstance(results[3], Exception):
            self.eth_usd = results[3]
    
    async def _fetch_usd_rub(self):
        """–ö—É—Ä—Å USD/RUB"""
        try:
            url = "https://api.exchangerate-api.com/v4/latest/USD"
            async with self.session.get(url, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['rates']['RUB']
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ USD/RUB: {e}")
            
            # –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫
            try:
                url = "https://api.frankfurter.app/latest?from=USD&to=RUB"
                async with self.session.get(url, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data['rates']['RUB']
            except Exception as e2:
                logger.error(f"–†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ USD/RUB —Ç–æ–∂–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e2}")
        
        return None
    
    async def _fetch_ton_price(self):
        """–¶–µ–Ω–∞ TON –≤ USD"""
        try:
            url = "https://api.coingecko.com/api/v3/simple/price"
            params = {
                "ids": "the-open-network",
                "vs_currencies": "usd",
                "include_24hr_change": "true"
            }
            
            async with self.session.get(url, params=params, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['the-open-network']['usd']
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ TON price: {e}")
            
            # –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —á–µ—Ä–µ–∑ Binance
            try:
                url = "https://api.binance.com/api/v3/ticker/price"
                params = {"symbol": "TONUSDT"}
                async with self.session.get(url, params=params, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        return float(data['price'])
            except Exception as e2:
                logger.error(f"–†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ TON —Ç–æ–∂–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e2}")
        
        return None
    
    async def _fetch_btc_price(self):
        """–¶–µ–Ω–∞ Bitcoin"""
        try:
            url = "https://api.coingecko.com/api/v3/simple/price"
            params = {
                "ids": "bitcoin",
                "vs_currencies": "usd"
            }
            async with self.session.get(url, params=params, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['bitcoin']['usd']
        except:
            return None
    
    async def _fetch_eth_price(self):
        """–¶–µ–Ω–∞ Ethereum"""
        try:
            url = "https://api.coingecko.com/api/v3/simple/price"
            params = {
                "ids": "ethereum",
                "vs_currencies": "usd"
            }
            async with self.session.get(url, params=params, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data['ethereum']['usd']
        except:
            return None
    
    def _format_number(self, number, decimals=2):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞"""
        if number is None:
            return "‚Äî"
        
        if self.config["number_format"] == "üá∑üá∫":
            # –†—É—Å—Å–∫–∏–π —Ñ–æ—Ä–º–∞—Ç: –ø—Ä–æ–±–µ–ª –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å —Ç—ã—Å—è—á, –∑–∞–ø—è—Ç–∞—è –¥–ª—è –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö
            formatted = f"{number:,.{decimals}f}"
            return formatted.replace(",", " ").replace(".", ",")
        else:
            # –ê–º–µ—Ä–∏–∫–∞–Ω—Å–∫–∏–π —Ñ–æ—Ä–º–∞—Ç: –∑–∞–ø—è—Ç–∞—è –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å —Ç—ã—Å—è—á
            return f"{number:,.{decimals}f}"
    
    async def _generate_price_post(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ—Å—Ç–∞ —Å —Ü–µ–Ω–∞–º–∏"""
        timestamp = datetime.now().strftime("%d.%m.%Y %H:%M:%S")
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
        post_text = f"<b>üí∞ –¶–ï–ù–´ –í –†–ï–ê–õ–¨–ù–û–ú –í–†–ï–ú–ï–ù–ò</b>\n"
        post_text += f"<code>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {timestamp}</code>\n\n"
        
        post_text += "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
        
        # USD/RUB
        if self.usd_rub:
            usd_formatted = self._format_number(self.usd_rub, 2)
            post_text += f"<b>üíµ USD/RUB:</b> <code>{usd_formatted}</code>\n"
        else:
            post_text += f"<b>üíµ USD/RUB:</b> <code>‚Äî</code>\n"
        
        # TON/USD
        if self.ton_usd:
            ton_formatted = self._format_number(self.ton_usd, 4)
            post_text += f"<b>üíé TON/USD:</b> <code>{ton_formatted}</code>\n"
        else:
            post_text += f"<b>üíé TON/USD:</b> <code>‚Äî</code>\n"
        
        post_text += "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
        
        # –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
        if self.config["show_crypto_pairs"]:
            if self.btc_usd:
                btc_formatted = self._format_number(self.btc_usd, 2)
                post_text += f"<b>‚Çø  BTC/USD:</b> <code>{btc_formatted}</code>\n"
            
            if self.eth_usd:
                eth_formatted = self._format_number(self.eth_usd, 2)
                post_text += f"<b>üü£ ETH/USD:</b> <code>{eth_formatted}</code>\n"
        
        post_text += "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–ª–µ–¥—É—é—â–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏
        update_in_min = self.config["posting_interval"] // 60
        post_text += f"<i>üîÑ –°–ª–µ–¥—É—é—â–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {update_in_min} –º–∏–Ω—É—Ç</i>\n"
        post_text += f"<i>üì¢ –ö–∞–Ω–∞–ª: @priceDollarTon</i>\n"
        
        # –í–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
        post_text += "‚îÄ" * 30
        
        return post_text
    
    async def on_unload(self):
        """–û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è"""
        self.is_running = False
        
        if self.task:
            self.task.cancel()
        
        if self.session:
            await self.session.close()
        
        logger.info("–ú–æ–¥—É–ª—å –≤—ã–≥—Ä—É–∂–µ–Ω")
